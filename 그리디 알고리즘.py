#그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법
#일반적인 그리디 알고리즘은 문제를 풀기위한 최소한의 아이디어를 떠올릴수있는 능력을 요구
#정당성 분석이 중요. 최적의해를 구할수있는지 검토
#루트 노드 부터 시작하여 거쳐가는 노드의 값의 합을 최대로만든다.
#최적의해는? Critical path랑 비슷한듯

#                  5
#        7        10            8
#  7   5  9       4   3        1 4 5

#거스름 돈 문제. 거스름돈 500원, 100원 10원, 거슬러줄돈 n 동전의 최소개수 구하라 N=1260일떄? 500 500 100 100 50 10 

n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array:   #나누는걸 반복하는거다 500 ,100 ,50 ,10 순서대로
    count +=n // coin #거슬러 줄 수 있는 동전의 개수 세기 
    n %= coin # %=연산자는 나눠주고 나머지를 왼쪽변수에 할당

print(count)


#화폐의 종류가 k라고할때, 소스코드의 시간복잡도는 0(K)이다.
#이알고리즘의 시간복잡도는 ㄱ거슬러줘야하는 금액과는 무관

# N이 1이 될때까지. N에서1을빼고, N을 K로나눈다. N이17 K가 4일때
#N과 K가 주어질때 과정을 수행해야되는 최소값

A = 17
B = 4
count = 0
while A == 1:
 count += (A - 1)  
 A //= B
print(count,"번 실행해야 N이 1이 됩니다.")