#그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법
#일반적인 그리디 알고리즘은 문제를 풀기위한 최소한의 아이디어를 떠올릴수있는 능력을 요구
#정당성 분석이 중요. 최적의해를 구할수있는지 검토
#루트 노드 부터 시작하여 거쳐가는 노드의 값의 합을 최대로만든다.
#최적의해는? Critical path랑 비슷한듯

#                  5
#        7        10            8
#  7   5  9       4   3        1 4 5

#거스름 돈 문제. 거스름돈 500원, 100원 10원, 거슬러줄돈 n 동전의 최소개수 구하라 N=1260일떄? 500 500 100 100 50 10 

n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array:   #나누는걸 반복하는거다 500 ,100 ,50 ,10 순서대로
    count +=n // coin #거슬러 줄 수 있는 동전의 개수 세기 
    n %= coin # %=연산자는 나눠주고 나머지를 왼쪽변수에 할당

print(count)


#화폐의 종류가 k라고할때, 소스코드의 시간복잡도는 0(K)이다.
#이알고리즘의 시간복잡도는 ㄱ거슬러줘야하는 금액과는 무관

# N이 1이 될때까지. N에서1을빼고, N을 K로나눈다. N이17 K가 4일때
#N과 K가 주어질때 과정을 수행해야되는 최소값

A = 17
B = 4
count = 0
while A == 1:
 count += (A - 1)  
 A //= B
print(count,"번 실행해야 N이 1이 됩니다.")



문제3. 모험가 길드 문제
한마을에 모험가가 n명, n명의 모험가를 대상으로 공포도를 측정
공포도가 높은 모험가는 쉽게 공포를 느껴 위험상황에서 제대로 대처할 능력이 떨어진다.는
모험가 길드장인 동빈이는 공포도가 x인 모험가는 반드시 x명 이상으로 구성한 모험가 그룹에 참여해야 여행을떠날수있도록 규정
여행을 떠날 수 있는 그룹 수의 최댓값 구해라

n=5이고 공포도가 2 3 1 2 2라고해보자
이경우 그룹1에 공포도가 1,2,3 인 모험가를 한명씩 넣고, 그룹2에 공포도가 2인 남은 두명을 넣게 되면 총 2개의 그룹을 만들 수 있다.
또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을필요는없다.

음 이거 볼때 일단 공포도가 낮은놈부터 정렬을해야됨 오름차순 정렬


1,2,2,2,3 이렇게 정렬해서
하나씩 확인해보면 현재 그룹에 포함된 모험가의 수가 현재 확인하고있는 공포도보다 크거나 같다면 이를 그룹으로 설정하면 됩니다.
 
data = [2, 3, 1, 2, 2]
data.sort() #오름차순정렬
    
result =0  # 총 그룹의 수
count = 0 #현재 그룹에 포함된 모험가의 수
    
for i in data: #공포도를 낮은것부터 하나씩 확인
        count += 1 # 현재 그룹에 해당 모험가를 포함시키기
        
        if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
                result += 1 #총그룹 수 증가
                count = 0 #현재 그룹에 포함된 모험가의 수 초기화
print(result) #총 그룹의 수 출력

현재그룹에 1 들어감
count가 1보다크다
result에 +1
count=0이되고

처음모험가는 1이므로 단일팀구성
다음팀원은 2이므로 22,팀 구성

마지막남은 2,3,은 3때문에 팀구성못함.
https://codingexplore.tistory.com/32
    


